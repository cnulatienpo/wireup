<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>What This Game Actually Teaches</title>
  <link rel="stylesheet" href="/wireup.css" />
</head>
<body>
  <main class="about-page">
    <h1 class="about-title">What This Game Teaches</h1>

    <section class="curriculum-content">
      <h2 class="section-header">TouchDesigner-Language Structured Curriculum</h2>

      <p>
        Wireup is a structured introduction to TouchDesigner’s evaluation model. It teaches
        operator-based computation, dependency-driven cooking, type compatibility, time-sliced
        execution, and network architecture.
      </p>
      <p>
        The curriculum builds cumulatively—each concept depends on the previous one.
      </p>

      <h3 class="section-header">What You Learn</h3>
      <ol class="curriculum-list">
        <li>
          <strong>Viewer as Status, Not Renderer</strong>
          <p>The Viewer shows the current output of an operator. It does not “render the project.”</p>
        </li>
        <li>
          <strong>Real-Time Evaluation Model</strong>
          <p>TouchDesigner runs continuously. Networks exist in a persistent evaluation context.</p>
        </li>
        <li>
          <strong>Data Types (Operator Families by Data Domain)</strong>
          <p>You learn the primary data domains:</p>
          <ul>
            <li>TOP — 2D image data (textures, pixel grids)</li>
            <li>CHOP — channel data (sampled numeric values over time)</li>
            <li>SOP — geometry data (points, primitives, attributes in 3D space)</li>
            <li>DAT — structured data (tables, text, scripts)</li>
            <li>Later: COMP containers and POP particle systems</li>
          </ul>
        </li>
        <li>
          <strong>Operators (Nodes)</strong>
          <p>
            Operators perform specific transformations and can include inputs, outputs,
            parameters, and optional internal state.
          </p>
        </li>
        <li>
          <strong>Connections (Directed Dependencies)</strong>
          <p>Flow direction defines dependency: downstream operators depend on upstream outputs.</p>
        </li>
        <li>
          <strong>Input vs Output</strong>
          <p>Inputs reference upstream results; outputs are computed results for downstream use.</p>
        </li>
        <li>
          <strong>Frame-Based Evaluation</strong>
          <p>A frame is one discrete network evaluation at time <em>t</em>.</p>
        </li>
        <li>
          <strong>Cooking (Demand-Driven Execution)</strong>
          <p>Operators cook only when requested; cooking propagates upstream from requests.</p>
        </li>
        <li>
          <strong>Branching (Fan-Out)</strong>
          <p>One output can feed multiple downstream operators; shared upstream nodes cook once per cycle.</p>
        </li>
        <li>
          <strong>Multiple Inputs</strong>
          <p>Some operators require ordered, semantically meaningful multiple inputs.</p>
        </li>
        <li>
          <strong>Type Compatibility</strong>
          <p>Inputs accept specific data types; conversion operators bridge incompatible types.</p>
        </li>
        <li>
          <strong>Internal State</strong>
          <p>Some operators preserve memory between evaluations (feedback, accumulation, history).</p>
        </li>
        <li>
          <strong>Accumulation Over Time</strong>
          <p>Stateful networks can integrate results across frames, where output at <em>t</em> depends on <em>t-1</em>.</p>
        </li>
        <li>
          <strong>Time as Data</strong>
          <p>Time can be read explicitly and used to drive oscillation, triggering, and modulation.</p>
        </li>
        <li>
          <strong>2D vs 3D Domains</strong>
          <p>TOP uses image space; SOP uses geometric space. Rendering needs a separate pipeline.</p>
        </li>
        <li>
          <strong>COMP (Network Encapsulation)</strong>
          <p>COMPs contain sub-networks for modularity while preserving dependency propagation.</p>
        </li>
        <li>
          <strong>Evaluation Order</strong>
          <p>Cooking starts at requested outputs and resolves upstream through the dependency graph.</p>
        </li>
        <li>
          <strong>Debugging via Dependency Tracing</strong>
          <p>Debugging means tracing inputs, output types, and cooking paths for null/mismatched nodes.</p>
        </li>
        <li>
          <strong>Network Structure and Readability</strong>
          <p>Clear grouping improves human traceability without changing execution semantics.</p>
        </li>
        <li>
          <strong>Automatic Evaluation (Continuous Mode)</strong>
          <p>Playback evaluates each frame continuously; manual stepping isolates evaluations for inspection.</p>
        </li>
      </ol>
    </section>

    <nav class="nav-buttons" aria-label="Page navigation">
      <a class="nav-button" href="/index.html">Back to Intro</a>
      <a class="nav-button" href="/game/index.html">Go to Game</a>
    </nav>
  </main>
</body>
</html>
